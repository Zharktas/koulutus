<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta charset="utf-8">
    <title>js2</title>
    
		<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
		<link href="../../assets/css/bootstrap.min.css" rel="stylesheet">
		<!--[if lt IE 9]>
			<script src="//html5shim.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
    <link href='http://fonts.googleapis.com/css?family=Bree+Serif' rel='stylesheet' type='text/css'>
		<link href="../../assets/css/slides-onepage.css" rel="stylesheet">
        	 		<link href="../../assets/css/slides.css" rel="stylesheet">

		<link href="../../assets/css/tamplr.css" rel="stylesheet">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/default.min.css">
	</head>
	<body>
    <div class="container">
      <div class="row">
        <div class="col-md-12">
          <h1 id="javascript">JavaScript</h1>
<p><a href="./">Kalvot</a></p>
<hr>
<h2 id="javascript-oliot">Javascript-oliot</h2>
<ul>
<li><p>Olioiden avulla JavaScriptin perustietotyypeistä voidaan koostaa suurempia
kokonaisuuksia</p>
</li>
<li><p>Olio on joukko avain-arvo-pareja, joissa avain on merkkijono ja
arvo mitä vain</p>
</li>
<li><p>Esimerkki:</p>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = {
  viesti: <span class="hljs-string">"Moi kaikki"</span>,
  tykkayksia: <span class="hljs-number">43</span>
};

<span class="hljs-comment">// Olion attribuuttiin voidaan viitata joko . tai [] syntaksilla</span>
<span class="hljs-keyword">var</span> v1 = obj1.viesti;
<span class="hljs-keyword">var</span> v2 = obj1[<span class="hljs-string">"viesti"</span>];

<span class="hljs-comment">// Myös uusia attribuutteja voidaan lisätä</span>
<span class="hljs-keyword">var</span> obj1.uusi = <span class="hljs-string">"hehe"</span>;</code></pre>

<ul>
<li><a href="http://www.w3schools.com/js/js_objects.asp">W3Schools: JavaScript Objects</a></li>
</ul>
<hr>
<h2 id="taulukko">Taulukko</h2>
<ul>
<li><p>JavaScriptissä on myös taulukko-tietotyyppi (Array)</p>
</li>
<li><p>Indeksoitava lista erityyppisiä alkioita</p>
</li>
<li><p>Esim.</p>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> juttuja = [<span class="hljs-number">200</span>, <span class="hljs-literal">true</span>, <span class="hljs-string">"Moi!"</span>];

<span class="hljs-comment">// Haetaan ensimmäinen (nollas) alkio, eli 200</span>
<span class="hljs-keyword">var</span> x = juttuja[<span class="hljs-number">0</span>];

<span class="hljs-comment">// Vaihdetaan alkio toiseksi</span>
juttuja[<span class="hljs-number">1</span>] = <span class="hljs-number">50</span>;

<span class="hljs-comment">// Lisätään uusi alkio</span>
juttuja.push(<span class="hljs-string">"heh"</span>);</code></pre>

<ul>
<li><a href="http://www.w3schools.com/js/js_arrays.asp">W3Schools: JavaScript Arrays</a>
ja <a href="http://www.w3schools.com/js/js_array_methods.asp">Array Methods</a></li>
</ul>
<hr>
<h2 id="kontrollirakenteet">Kontrollirakenteet</h2>
<ul>
<li>JavaScriptin kontrollirakenteet ovat samantapaisia kuin monessa muussa
ohjelmointikielessä</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (x === <span class="hljs-number">5</span> &amp;&amp; y &lt; <span class="hljs-number">2</span>) {
  alert(<span class="hljs-string">"jee"</span>);
}
<span class="hljs-keyword">else</span> {
  alert(<span class="hljs-string">"buu"</span>);
}</code></pre>

<pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (x &lt; <span class="hljs-number">10</span> || jotain()) {
  x += <span class="hljs-number">5</span>;
}</code></pre>

<pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i &lt; taulukko.length; ++i) {
  <span class="hljs-built_in">console</span>.log(i, taulukko[i]);
}</code></pre>

<ul>
<li>W3Schools:
<a href="http://www.w3schools.com/js/js_if_else.asp">if</a>,
<a href="http://www.w3schools.com/js/js_loop_for.asp">for</a>,
<a href="http://www.w3schools.com/js/js_loop_while.asp">while</a></li>
</ul>
<hr>
<h2 id="vertailu">Vertailu</h2>
<ul>
<li><p>Vertailuoperaattoritkin näyttävät samoilta kuin monessa muussa
kielessä, <strong>mutta</strong> erityisesti yhtäsuuruusvertailun kanssa on oltava
tarkkana</p>
</li>
<li><p>Operaattori <code>==</code> testaa ovatko arvot mahdollisen tyyppimuunnoksen
jälkeen samat</p>
<ul>
<li>johtaa outouksiin, esimerkki:</li>
</ul>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-string">''</span> == <span class="hljs-number">0</span>   <span class="hljs-comment">// false</span>
 <span class="hljs-number">0</span> == <span class="hljs-string">''</span>  <span class="hljs-comment">// true</span>
 <span class="hljs-number">0</span> == <span class="hljs-string">'0'</span> <span class="hljs-comment">// true</span></code></pre>

<ul>
<li>Operaattori <code>===</code> sen sijaan tarkastaa aidon yhtäsuuruuden<ul>
<li>Kannattaa lähes aina käyttää sitä</li>
<li>Sama operaattoreille <code>!=</code> ja <code>!==</code></li>
</ul>
</li>
</ul>
<hr>
<h2 id="funktioista">Funktioista</h2>
<ul>
<li><p>JavaScriptissä funktiot ovat ns. ensimmäisen luokan kansalaisia (first class functions).
Funktioita voi näin ollen mm.</p>
<ul>
<li>sijoittaa muuttujiin</li>
<li>välittää parametreina</li>
<li>luoda nimettöminä</li>
<li>luoda toistensa sisällä</li>
<li>käyttää tiedon piilottamiseen</li>
<li>ja olioiden luomiseen</li>
</ul>
</li>
<li><p>Funktio on näin ollen hyvin keskeinen käsite JavaScriptissä</p>
</li>
</ul>
<hr>
<h2 id="n-kyvyysalueet">Näkyvyysalueet</h2>
<ul>
<li><p>Monissa ohjelmointikielissä, kuten Javassa ja C++:ssa,
näkyvyysalue on koodilohkokohtainen (block scope)</p>
<ul>
<li>Muuttujat jotka määritellään koodilohkon sisällä, näkyvät vain ko. lohkon sisällä</li>
</ul>
</li>
<li><p>JavaScriptissa tämä on tehty vähän toisella tavalla...</p>
</li>
</ul>
<hr>
<h2 id="javascriptin-n-kyvyysalueet">JavaScriptin näkyvyysalueet</h2>
<ul>
<li><p>JavaScriptissä näkyvyysaluetta ei määritä koodilohko vaan funktio (function scope)</p>
<ul>
<li>Kaikki funktion sisällä määritellyt muuttujat näkyvät fuktion sisällä</li>
<li>Esimerkiksi silmukan sisällä määritelty muuttuja on olemassa myös silmukan ulkopuolella!</li>
</ul>
</li>
<li><p>JavaScriptissä on myös ns. eksplisiittinen globaali näkyvyysalue</p>
<ul>
<li>Kaikki muuttujat, joita ei ole määritelty funktion sisällä ovat globaaleja</li>
<li>Kaikki muttujat, joiden määrittelyn edessä ei ole avainsanaa <code>var</code> ovat globaaleja!</li>
</ul>
</li>
</ul>
<hr>
<h2 id="n-kyvyysalue-esimerkki">Näkyvyysalue-esimerkki</h2>
<pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> y = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// x ja y näkyvät täällä</span>
  }

  <span class="hljs-comment">// x näkyy, y ei</span>

  <span class="hljs-keyword">return</span> bar;
}

<span class="hljs-comment">// x ei näy, eikä y</span></code></pre>

<ul>
<li>Funktio <code>bar</code> näkee <code>x</code>:n ja <code>y</code>:n niin kauan kuin se on olemassa,
vaikka olemassaolo jatkuisi <code>foo</code>:n suoritusta kauemmin<ul>
<li>Näin voi käydä <code>return bar;</code> lauseesta johtuen</li>
</ul>
</li>
</ul>
<hr>
<h2 id="kapselointi">Kapselointi</h2>
<ul>
<li><p>JavaScriptistä puuttuu moduulien ja kooditiedostojen riippuvuuksen hallinta.</p>
<ul>
<li>Tiedostot liitetään HTML-koodiin script elementillä</li>
<li>Ohjelmoijan täytyy itse keksiä, miten hoitaa keskenäiset riippuvuudet</li>
</ul>
</li>
<li><p>On kuitenkin harhakäsitys, että JavaScript-koodia ei pystyisi kapseloimaan ja jakamaan osiin.</p>
</li>
<li><p>JavaScriptissä tämä tehdään vain hieman eri tavalla</p>
<ul>
<li>sulkeumat (closure)</li>
<li>anonyymit funktiot</li>
<li>JavaScript objektit</li>
</ul>
</li>
<li><p>JavaScript ei näin ollen kielenä oikeuta spaghettikoodin kirjoittamiseen!</p>
</li>
</ul>
<hr>
<h2 id="klosuuri-esimerkki">Klosuuri-esimerkki</h2>
<pre><code class="hljs javascript"><span class="hljs-comment">//Luodaan tilallinen counter funktio</span>
<span class="hljs-comment">//anonyymin funktion ja sulkeuman avulla</span>

<span class="hljs-keyword">var</span> counter = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; <span class="hljs-comment">//Tämä ei näy ulospäin</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> ++i;
    }
}());

<span class="hljs-keyword">var</span> id = counter();
<span class="hljs-comment">//ensimmäinen kutsu palauttaa arvon 1 ja seuraava 2 jne.</span></code></pre>

<hr>
<h2 id="klosuuri">Klosuuri</h2>
<ul>
<li><p>Esimerkkikoodissa luodaan counter -funktio anonyymin funktion ja sulkeuman avulla</p>
</li>
<li><p>Anonyymi funktio suoritetaan heti ja sen suorituksen aikana muuttujan i arvo sidotaan.</p>
</li>
<li><p>Funktio ei kuitenkaan palauta i:n arvoa vaan funktion, joka näkee i:n arvon ja psytyy manipuloimaan sitä. Muuttuja counter viittaa siis sisempänä määriteltyyn funktioon!</p>
</li>
<li><p>Näin ollen, kun funktiota counter kutsutaan, palautetaan aina seuraava i:n arvo.</p>
</li>
</ul>
<hr>
<h2 id="klosuuri">Klosuuri</h2>
<ul>
<li>Klosuuria ei ole pakko luoda anonyyminä funktiona vaan siitä voi tehdä instantioitavan käyttämällä nimettyä funktiota. Mekanismia voidaan käyttää myös olioiden rakentamiseen.</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-comment">//Instantioitava laskuri</span>
<span class="hljs-keyword">var</span> counter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">initialValue</span>)</span>{
    <span class="hljs-keyword">var</span> i = initialValue;
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> ++i;
    }
};

<span class="hljs-keyword">var</span> counter1 = counter(<span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> counter2 = counter(<span class="hljs-number">30</span>);

<span class="hljs-keyword">var</span> id1 = counter1();<span class="hljs-comment">//1</span>
<span class="hljs-keyword">var</span> id2 = counter2();<span class="hljs-comment">//31</span></code></pre>

<hr>
<h2 id="klosuuri">Klosuuri</h2>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">initialValue</span>)</span>{
    <span class="hljs-keyword">var</span> i = initialValue;
    <span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-built_in">console</span>.log(i);
    }
    <span class="hljs-keyword">var</span> public = {};
    public.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        ++i;
        print();
        <span class="hljs-keyword">return</span> i;
    }
    public.decrement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        --i;
        print();
        <span class="hljs-keyword">return</span> i;
    }
    <span class="hljs-keyword">return</span> public;
};</code></pre>

<hr>
<h2 id="nimiavaruuden-rakentaminen-js-olioilla">Nimiavaruuden rakentaminen JS-olioilla</h2>
<pre><code class="hljs javascript"><span class="hljs-comment">//Luodaan tyhjä JavaScript objekti nimiavaruudeksi,</span>
<span class="hljs-comment">//jos sellaista ei ole jo määritelty</span>
<span class="hljs-keyword">var</span> nimiavaruus = nimiavaruus || {};

<span class="hljs-comment">//Lisätään nimiavaruuteen metodeja</span>
nimiavaruus.counter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">initialValue</span>)</span>{
    <span class="hljs-keyword">var</span> i = initialValue;
    <span class="hljs-keyword">var</span> public = {};
    public.increment = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> ++i;
    }
    public.decrement = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> --i;
    }
    <span class="hljs-keyword">return</span> public;
};</code></pre>

<hr>
<h2 id="nimiavaruuden-rakentaminen-js-olioilla">Nimiavaruuden rakentaminen JS-olioilla</h2>
<ul>
<li><p>Edellisessä esimerkissä käytettiin JavaScript -objektia nimiavaruutena. Ideana on yksinkertaisesti kapseloida kaikki omaan ohjelmaan liittyvät jutut yhden objektin sisään.</p>
</li>
<li><p>Mutta miksi ihmeessä näin kannattaa tehdä?</p>
</li>
</ul>
<hr>
<h2 id="nimiavaruuden-rakentaminen-js-olioilla">Nimiavaruuden rakentaminen JS-olioilla</h2>
<ul>
<li><p>JavaScriptin gobaali näkyvyysalue on siitä pirullinen, että se on ihan oikeasti globaali eikä esimerkiksi tiedostokohtainen.</p>
</li>
<li><p>Jos määrittelet muuttujan a joka on globaali koodisasi ja kirjasto, jota käytät määrittelee globaalin muuttujan a, toinen tulee ylikirjoitetuksi. Jälkimmäisenä määritelty jää voimaan.</p>
</li>
<li><p>Ja mikä parasta, tästä ei edes välttämättä tule mitään virheilmoitusta vaan virhe voi esiintyä hyvinkin mystisenä koodin toiminnallisena bugina.</p>
</li>
</ul>
<hr>
<h2 id="funktioiden-kutsuminen-ja-suorituskonteksti">Funktioiden kutsuminen ja suorituskonteksti</h2>
<ul>
<li><p>JavaScript funktioita voidaan kutsua usealla tavalla</p>
<ul>
<li>Funktioina</li>
<li>Metodina</li>
<li>Rakentajana</li>
<li>Call ja apply -metodeilla</li>
</ul>
</li>
<li><p>Funktion kutsutapa vaikuttaa siihen, missä kontekstissa koodia suoritetaan</p>
<ul>
<li>konteksti on talletettu <code>this</code> muuttujaan</li>
<li>kontekesti voi olla kutsu tavasta riippuen<ul>
<li>funktiokonteksti</li>
<li>globaalikonteksti</li>
<li>eval-konteksti (erikoisuus, jota ei käydä läpi tällä kertaa)</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="funktion-kutsuminen-funktiona">Funktion kutsuminen funktiona</h2>
<ul>
<li><p>Funktiota kutsutaan funktiona silloin kun se ei ole jäsen (metodi).</p>
</li>
<li><p>Tällöin <code>this</code> sidotaan globaaliin kontekstiin</p>
<ul>
<li><code>this</code> viittaa window -objektiin</li>
</ul>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myFunction = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
};

myFunction();
<span class="hljs-comment">//tulostaa konsoliin selaimen window-objektin</span></code></pre>

<hr>
<h2 id="funktion-kutsuminen-metodina">Funktion kutsuminen metodina</h2>
<ul>
<li>Kun funktiota kutsutaan metodina, konteksti sidotaan objektiin, jonka metodia kutsutaan (funktiokonteksti)<ul>
<li>Se missä ja miten metodi on määritelty, ei vaikuta kontekstin sidontaan</li>
<li>Se, miten funktiota kutsutaan vaikuttaa</li>
</ul>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myObject = {};

myObject.myMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
};

myObject.myMethod();
<span class="hljs-comment">//tulostaa konsoliin myObject -objektin</span></code></pre>

<hr>
<h2 id="funktion-kutsuminen-rakentajana">Funktion kutsuminen rakentajana</h2>
<ul>
<li><p>Funktioita on mahdollista kutsua rakentajina käyttäen new -avainsanaa.</p>
</li>
<li><p>JavaScriptissä new ei kuitenkaan varaa muistia vaan vaihtaa suorituksen kontekstia.</p>
<ul>
<li>Kun funktiota kutsutaan rakentajana <code>this</code> sidotaan luotuun objektiin (tai objektiin, jonka rakentaja eksplisiittisesti palauttaa)</li>
<li>Suoritus on funktiokontekstissa</li>
</ul>
</li>
<li><p>New on hieman kintsofreninen osa JavaScriptiä ja sen kanssa tulee olla hyvin varovainen</p>
<ul>
<li>Palataan tähän vielä tarkemmin prototyyppi -osiossa.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="funktion-kutsuminen-rakentajana">Funktion kutsuminen rakentajana</h2>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> MyObject = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">this</span>.method = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-comment">//toiminnallisuutta</span>
    }
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
}
<span class="hljs-keyword">var</span> myInstance = <span class="hljs-keyword">new</span> MyObject();
<span class="hljs-comment">//tulostaa konsoliin viitteen MyObjektin -kontekstiin</span></code></pre>

<hr>
<h2 id="call-ja-apply">Call ja Apply</h2>
<ul>
<li><p><code>call</code> ja <code>apply</code> ovat erikoismetodeja, joiden avulla funktion kutsun yhteydessä voidaan määrittää funktion suorituskonteksti.</p>
</li>
<li><p><code>call</code>:lle annetaan konteksti ja parametrit</p>
</li>
<li><code>apply</code>:lle annetaan konteksti ja parametrit taulukkona</li>
</ul>
<pre><code class="hljs javascript">metodi.call(konteksti, p1, p2, p3);
metodi.apply(konteksti, [p1, p2, p3]);</code></pre>

<hr>
<h2 id="prototype-ja-periytyminen">Prototype ja periytyminen</h2>
<ul>
<li><p>Kuten ihan luennon alussa mainittiin, JavaScript on ns. prototyyppipohjainen kieli.</p>
</li>
<li><p>Sillä tarkoitetaan, että perintä JavaScriptissä on tehty porotyyppien avulla</p>
<ul>
<li>Jokaisella JavaScript objektilla on prototyyppi, joka sisältää objektin perimän</li>
<li>Jos objektille kutsutaan metodia, jota siltä itseltään ei löydy, sitä etsitään seuraavaksi prototyypistä</li>
</ul>
</li>
<li><p>Periytymishierarkia voi olla kuinka syvä tahansa</p>
<ul>
<li>Lopulta päädytään Object -objektiin, josta kaikki JavaScript objektit periytyvät.</li>
</ul>
</li>
</ul>
<hr>
<h2 id="prototype-ja-periytyminen">Prototype ja periytyminen</h2>
<pre><code class="hljs javascript"><span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">'function'</span>){
    <span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">o</span>)</span>{
        <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{}
        F.prototype = o;
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();
    }
}</code></pre>

<ul>
<li><p>Object.create metodin avulla voidaan luoda uusi objekti, jonka prototyypiksi tulee funktion parametriksi asetettu objekti. --&gt; Eli saatiin periytettyä objekti parametriksi annetusta objektista.</p>
</li>
<li><p>Object.create metodi tuli mukaan vasta ECMAScript 5.1. standardissa vuonna 2011</p>
</li>
</ul>
<hr>
<h2 id="periytymisesimerkki">Periytymisesimerkki</h2>
<pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myMammal = {
    name : <span class="hljs-string">"Herb the Mammal"</span>,
    get_name : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;
    },
    says : <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.saying || <span class="hljs-string">""</span>;
    }
};

<span class="hljs-keyword">var</span> myCat = <span class="hljs-built_in">Object</span>.create(myMammal);
cat.name = <span class="hljs-string">"Henrietta"</span>;
cat.saying = <span class="hljs-string">"meow"</span>;
myCat.get_name = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.says()+<span class="hljs-string">" "</span>+<span class="hljs-keyword">this</span>.name+<span class="hljs-string">" "</span>+<span class="hljs-keyword">this</span>.says();
};</code></pre>

<hr>
<h2 id="yleisimm-t-sudenkuopat">Yleisimmät sudenkuopat</h2>
<ul>
<li><p>Eksplisiittinen globaali näkyvyysalue</p>
<ul>
<li>Muista var</li>
<li>Kapseloi koodisi!</li>
</ul>
</li>
<li><p><code>this</code> avainsana</p>
<ul>
<li>Se mihin <code>this</code> viittaa riippuu siitä, miten funktiota kutsutaan ei siitä, miten ja missä se on määritelty.</li>
<li>Jotkut kirjastot, kuten jQuery pakottavat käytännössä käyttämään <code>this</code> -avainsanaa<ul>
<li>Kirjasto kuitenkin hoitaa homman siten, että funktiota kutsutaan käytännössä aina funktio kontekstissa.</li>
</ul>
</li>
</ul>
</li>
<li><p><code>new</code> avainsana</p>
<ul>
<li>Ei varaa muistia vaan vaihtaa kontekstia</li>
<li>Jos pystyt tekemään sen, mitä halaut ilman new:tä, niin tee mielummin niin</li>
</ul>
</li>
</ul>
<hr>
<h1 id="yleisimm-t-sudenkuopat">Yleisimmät sudenkuopat</h1>
<ul>
<li><p>Vertailuoperaattorit == ja ===</p>
<ul>
<li>== tarkastaa, voiko arvot tyyppikonversioiden kautta tulkita samoiksi</li>
<li>=== tarkastaa aidon yhtäsuuruuden</li>
<li>Löytyy myös != ja !== operaattorit</li>
</ul>
</li>
<li><p>Vertailuoperaattoreista kannattaa lukea lisää vaikka <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators">täältä</a></p>
</li>
</ul>
<hr>
<h1 id="l-hteit-ja-linkkej-">Lähteitä ja Linkkejä</h1>
<ul>
<li><p>Prototyyppiin liittyvät esimerkit ovat otettu Crockfordin JavaScript: the Good Parts kirjasta</p>
<ul>
<li>Youtubesta löytyy myös Crockfordin <a href="https://www.youtube.com/watch?v=hQVTIJBZook">luento</a></li>
</ul>
</li>
<li><p>Lähteenä on käytetty myös <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript">Mozilla Developper Networkin</a> JavaScript materiaaleja, joita voin suositella referenssimateraaliksi.</p>
</li>
<li><p>Itseopiskeluun apua voi löytää myös <a href="http://www.w3schools.com/js/">w3schoolsista</a></p>
</li>
</ul>
<hr>
<h2 id="domcontentloaded">DOMContentLoaded</h2>
<ul>
<li><p>Kun JavaScriptia aletaan suorittaa, ei koko dokumentti välttämättä ole
vielä latautunut</p>
<ul>
<li>tällöin DOM:n käsittely voi epäonnistua tai aiheuttaa jotain
epätoivottua</li>
</ul>
</li>
<li><p>Asia korjaantuu kun aloittaa JavaScriptin suorituksen
vasta dokumentin latauduttua</p>
<ul>
<li>onnistuu (mm.) kuuntelemalla <code>document</code>-olion
<code>DOMContentLoaded</code>-tapahtumaa</li>
</ul>
</li>
</ul>
<pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-comment">// Dokumentti ladattu.</span>
  <span class="hljs-comment">// Suoritettava koodi tänne.</span>
});</code></pre>




        </div>
      </div>
    </div>
    <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
    <script src="../../assets/js/bootstrap.min.js"></script>
    <script src="../../assets/js/scripts.js"></script>
	</body>
</html>
